<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LLC&#39;s blog</title>
  
  <subtitle>与其感慨路难行，不如马上出发</subtitle>
  <link href="https://llcblog.com/atom.xml" rel="self"/>
  
  <link href="https://llcblog.com/"/>
  <updated>2023-03-22T05:24:37.147Z</updated>
  <id>https://llcblog.com/</id>
  
  <author>
    <name>Lichen Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>北京周末</title>
    <link href="https://llcblog.com/2023/03/22/%E5%8C%97%E4%BA%AC%E5%91%A8%E6%9C%AB/"/>
    <id>https://llcblog.com/2023/03/22/%E5%8C%97%E4%BA%AC%E5%91%A8%E6%9C%AB/</id>
    <published>2023-03-22T05:21:48.000Z</published>
    <updated>2023-03-22T05:24:37.147Z</updated>
    
    <content type="html"><![CDATA[<p>本来上周末计划朋友来天津考试顺便玩两天，没想到那个怂包感觉自己考试肯定过不了直<br>接弃考不来了，遂放弃，临时改成和媳妇去北京玩。</p><p>天津到北京的车挺多，但人也不少，来去的时候车上基本都坐满了。周日回来的票一开始<br>买的下午三点，感觉太早了改签到六点，幸亏周六出发的时候就改签了，周日再改签的话<br>基本上是没票。</p><p>周六早上打车去车站，c打头的火车一个来小时就到了北京南站。到北京后想先去吃饭，<br>脑子里想的是去大悦城顺便逛街，结果西单大悦城记成东单了，地铁坐错了浪费将近半个<br>小时寻思算了直接去王府井吧。</p><p>到了王府井发现现在人比我前几年来的时候少了好多，稍微溜达了一会儿在一个地下美食<br>广场吃了个麻辣烫，算是媳妇在北京的第一餐（不算火车上吃的四个丑橘）。</p><p>吃完饭去天安门，人贼多，去长安街就得先验身份证，结果到天安门地铁站门口人告诉我<br>天安门现在需要提前预约，不然进不了。一看预约时间今天是没戏了，转头就去景山公园。<br>景山公园人也不少，不过感觉也没啥逛的，基本上就只能朝一个方向顺着人流走。跟着大<br>流上了小山头，在那几个亭子那看了眼故宫。里面有卖冰淇淋的，这时候贼后悔没在王府<br>井排那个吴裕泰冰淇淋，虽然不知道啥味儿。</p><p>下来就直接步行去了荷花市场，南锣鼓巷那有个卖爆肚的，媳妇以为是那种辣的，斥巨资<br>买了一份儿，结果一口下去就吃不了，味贼重，后来我都给吃了顺便嘲讽她肯定也吃不了<br>卤煮（虽然我也在没吃过）。</p><p>从南锣鼓巷出来就是晚饭点儿，一路步行到簋街，看到美团上胡大饭馆小龙虾好吃，过去<br>寻思取个号。好家伙，不取不知道，取了吓一跳哇，开着的几家店排号没有下300的，总<br>店更是排了1000桌，等了一会儿发现今晚吃它无望赶紧在旁边找了一家湘菜吃。</p><p>吃饭等位的时候看了下周围的宾馆，基本都是四五百左右，媳妇心疼钱找便宜的，看见一<br>个319 的速八，寻思速八也不是小牌子就定了，结果吃完饭过去发现环境极差，没热水，<br>有味儿隔音还差，想随便看看电视结果总共就7个台，还都是雪花，差评中的差评。</p><p>第一天走了两万多步，有点脚疼，随便涮了涮就休息了。</p><p>因为破旅店隔音太差，听了一晚上呼噜和楼道里的动静，周日早上起来精神头相当一般，<br>九点半出门想买个早点，结果发现太晚了早点都收摊了。因为脚疼头天预约的天安门也不<br>想去了，下次连故宫一起，先打车去西单吃个饭。</p><p>到了西单大悦城，脚疼也不想逛，看着广告想去吃那个费大厨辣椒炒肉，结果前面又排几<br>十号。找了个不排号的撒椒吃了吃，他家的甜皮鸭还不错。地下B2 有一家一撇一捺，媳<br>妇喜欢她家的耳环，过去逛了逛买了两个，店员是个社牛，贼热情，赶紧非常热爱她的工<br>作，回头还加微信帮忙找了找老款式（可惜没找到）。</p><p>下午坐地铁去了动物园，本来加了四块钱看熊猫，结果熊猫那人太多，排队起码半个小时<br>就没看。其他地方人也很多，动物数量很少而且基本都在休息，就看哪聚集了人就过去瞅<br>一眼，反正大半部分动物也不搭理你，看个懒洋洋的睡姿（这帮家伙上班就是睡觉，羡慕<br>的不行）。</p><p>从狮虎山出来过桥看大象，说实话大象味儿是真大，粑粑比人腿都粗，屋里也比较热，赶<br>紧出来去河马犀牛什么的那边，这有个小餐厅，坐下歇了会儿。继续往前走是鹰山，结果<br>也就一只鹰在山头上坐着，没啥劲。往回走看猴儿，整个动物园感觉就猴儿多，还有个人<br>在那扔香肠逗猴儿，本来还寻思这都关着呢怎么还都是禁止投喂的标语，这哥们儿就给我<br>演示了一下。后面因为脚疼和火车时间快到了，匆匆离开。</p><p>这次临时起意去北京，啥也没准备，而且这个时间景点儿人已经特别多了，去哪都是匆匆<br>忙忙被人推着走，体验相当一般。下次出去玩起码得提前几天做做攻略，不然哪哪儿都排<br>队啥也干不成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来上周末计划朋友来天津考试顺便玩两天，没想到那个怂包感觉自己考试肯定过不了直&lt;br&gt;接弃考不来了，遂放弃，临时改成和媳妇去北京玩。&lt;/p&gt;
&lt;p&gt;天津到北京的车挺多，但人也不少，来去的时候车上基本都坐满了。周日回来的票一开始&lt;br&gt;买的下午三点，感觉太早了改签到六点，幸亏</summary>
      
    
    
    
    
    <category term="北京" scheme="https://llcblog.com/tags/%E5%8C%97%E4%BA%AC/"/>
    
    <category term="旅游" scheme="https://llcblog.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>manjaro kde 升级后中文字体变成方块</title>
    <link href="https://llcblog.com/2021/02/18/manjaro-kde-plasma-font/"/>
    <id>https://llcblog.com/2021/02/18/manjaro-kde-plasma-font/</id>
    <published>2021-02-18T14:55:29.000Z</published>
    <updated>2021-02-18T15:02:20.026Z</updated>
    
    <content type="html"><![CDATA[<p>通过<code>yaourt -Syu</code> 升级系统后，重启电脑进入kde 桌面发现菜单栏等中文的地方变成了方块，尝试重新安装了<code>wqy-microhei</code> 并重启后依然无效。</p><p>于是直接搜索设置font，发现所有字体都变成了<code>Noto Mono</code>，调整为<code>WenQuanYi Micro Hei</code> 后恢复正常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过&lt;code&gt;yaourt -Syu&lt;/code&gt; 升级系统后，重启电脑进入kde 桌面发现菜单栏等中文的地方变成了方块，尝试重新安装了&lt;code&gt;wqy-microhei&lt;/code&gt; 并重启后依然无效。&lt;/p&gt;
&lt;p&gt;于是直接搜索设置font，发现所有字体都变成了&lt;c</summary>
      
    
    
    
    
    <category term="font" scheme="https://llcblog.com/tags/font/"/>
    
    <category term="manjaro" scheme="https://llcblog.com/tags/manjaro/"/>
    
    <category term="坑" scheme="https://llcblog.com/tags/%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>sk_buff 简介</title>
    <link href="https://llcblog.com/2020/10/26/how-sk-buff-work/"/>
    <id>https://llcblog.com/2020/10/26/how-sk-buff-work/</id>
    <published>2020-10-26T03:18:06.000Z</published>
    <updated>2020-11-21T12:07:51.315Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://elixir.bootlin.com/linux/v5.9/source/include/linux/skbuff.h#L713" target="_blank" rel="noopener">sk_buff</a> 是Linux 网络中的重要数据结构，每个包的发送和接收都要处理这个结构体。</p><p>这个结构体比较长，只讨论部分字段。开头是一个联合，它要么在一个链表里，要么在一个rb tree（netem/tcp)里。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* These two members must be first. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>*<span class="title">dev</span>;</span></span><br><span class="line"><span class="comment">/* Some protocols might use this space to store information,</span></span><br><span class="line"><span class="comment"> * while device pointer would be NULL.</span></span><br><span class="line"><span class="comment"> * UDP receive path is one user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>dev_scratch;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span><span class="title">rbnode</span>;</span> <span class="comment">/* used in netem, ip4 defrag, and tcp stack */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是一个sock 字段，显然是和这个skb 关联的socket，当这个包是socket 发出或接收时，这里指向对应的socket，而如果是转发包，这里是null.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br></pre></td></tr></table></figure><p>随后是一个时间戳字段，用于记录包发送或接收到的时间。net_enable_timestamp() 和net_disable_timestamp() 函数可用于启用或禁用时间戳。在用户态，可以通过socket 选项SIOCGSTAMP 管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ktime_t</span> tstamp;</span><br></pre></td></tr></table></figure><p>之后有一组长度相关的字段，其中len 是数据包的长度，data_len 是不存在于线性buffer，而是使用page buffer 的数据的大小，两者之差则是位于线性buffer 的数据大小，skb_headlen() 函数用于计算这个值。后续会讨论线性buffer 和page buffer.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>len,</span><br><span class="line">data_len;</span><br><span class="line">__u16mac_len,</span><br><span class="line">hdr_len;</span><br></pre></td></tr></table></figure><p>跳过中间的部分，直接看到协议头相关的字段，这些头部字段保存的是基于skb-&gt;head 的偏移量，有一组skb_set/reset/_*_header() 的方法去设置他们，使用时，skb_*_header() 方法会将skb-&gt;head + offset 的结果返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__be16protocol;</span><br><span class="line">__u16transport_header;</span><br><span class="line">__u16network_header;</span><br><span class="line">__u16mac_header;</span><br></pre></td></tr></table></figure><p>最后是skb 的尾部，这些字段必须位于sk_buff 结构的结尾，而且data 是可变长的部分，也就是前面提到的线性buffer，这里可以存放一部分包的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line"><span class="keyword">sk_buff_data_t</span>tail;</span><br><span class="line"><span class="keyword">sk_buff_data_t</span><span class="built_in">end</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>*head,</span><br><span class="line">*data;</span><br></pre></td></tr></table></figure><p>这部分线性buffer 由以上四个指针控制，分割成三个部分，这四个指针都指向线性buffer 中的位置：</p><ul><li>head 到data 之间，称为headroom.</li><li>data 到tail 之间，存放包的数据。</li><li>tail 到end 之间，称为tailroom.</li></ul><p><img src="skb_layout.png" alt=""></p><p>对于刚刚通过alloc_skb() 方法申请出来的skb，head,tail,data 三个指针都指向同一位置，而tail 和end 之间有一段根据alloc_skb(len, flag) 方法的参数申请出来的空间。</p><p><img src="skb_fresh.png" alt=""></p><p>为了给协议头预留空间，可以使用skb_reserve(skb, head_len)方法，该方法会根据参数将data 指针后移，扩展headroom.</p><p><img src="skb_after_reserve.png" alt=""></p><p>可以通过skb_put(skb, data_len) 方法移动tail 指针，扩展用户数据空间。该方法同时会增加skb-&gt;len.</p><p><img src="skb_after_user_put.png" alt=""></p><p>这些空间都是从tailroom “挤”出来的，因此需要保证tailroom 有足够的空间。另外要注意skb_put() 只能在没有page 的数据的情况下调用。<br>为了添加协议头的内容，需要调用skb_push()方法，这个方法和skb_put()类似，但它是从headroom 挤出空间，data 指针会往前移动，它同样会增加skb-&gt;len.</p><p>添加一个四层头：</p><p><img src="skb_after_udp_push.png" alt=""></p><p>再添加一个三层头：</p><p><img src="skb_after_ip_push.png" alt=""></p><p>以上是对于没有page buffer，只有线性buffer 时的操作，对于比较大的包，还需要用到线性buffer 以外的部分。对于部分驱动来讲，有一个copybreak 的字段，当包的大小大于copybreak 时，只将起始一部分数据放入skb-&gt;data（协议头等），而剩余部分会存放于page buffer. 后续添加数据时应该不再调用skb_put()方法，否则数据顺序是有问题的。</p><p>skb_is_nonlinear() 方法可以帮助判断是否存在page buffer，对于有page buffer 的skb 来讲，之前已经提到skb-&gt;data_len 用于指示这部分数据的大小，而之前刚刚提到的通过skb_put() 和skb_push() 方法添加进去的数据的大小就是skb-&gt;len-skb-&gt;data_len，也就是skb_headlen()。</p><p>对于page 的数据，使用skb_frag_t 的数据结构存放。在新版本的内核中，skb_frag_t 是 <code>typedef bio_vec skb_frag_t</code>. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>*<span class="title">bv_page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>bv_len;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>bv_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构是一个page，len，offset 的三元组，指示了数据在哪个page 的哪个offset 处，长度为多少。</p><p>skb_shared_info 用于记录frag 相关的信息，nr_frags 指示了在frags[] 中有多少个frags.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">__u8__unused;</span><br><span class="line">__u8meta_len;</span><br><span class="line">__u8nr_frags;</span><br><span class="line">__u8tx_flags;</span><br><span class="line"><span class="keyword">unsigned</span> shortgso_size;</span><br><span class="line"><span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line"><span class="keyword">unsigned</span> shortgso_segs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">frag_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>gso_type;</span><br><span class="line">u32tskey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic_t</span>dataref;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment"> * remains valid until skb destructor */</span></span><br><span class="line"><span class="keyword">void</span> *destructor_arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line"><span class="keyword">skb_frag_t</span>frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用skb_shinfo() 可以获取skb_shared_info 的指针，而这个指针正是skb-&gt;end 指向的位置（或计算偏移量后的位置），也就是tailroom 的后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> skb_shinfo(SKB)((struct skb_shared_info *)(skb_end_pointer(SKB)))</span></span><br></pre></td></tr></table></figure><p>在接收数据时，驱动一般调用skb_add_rx_frag() 方法添加page buffer 数据，而该方法实际上调用了skb_fill_page_desc()，后者是会将page，offset，len （即skb_frag_t) 和新的frag 数量更新到skb_shared_info.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">skb_add_rx_frag</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> i, struct page *page, <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> truesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">skb_fill_page_desc(skb, i, page, off, <span class="built_in">size</span>);</span><br><span class="line">skb-&gt;len += <span class="built_in">size</span>;</span><br><span class="line">skb-&gt;data_len += <span class="built_in">size</span>;</span><br><span class="line">skb-&gt;truesize += truesize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">skb_fill_page_desc</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct page *page, <span class="keyword">int</span> off, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__skb_fill_page_desc(skb, i, page, off, <span class="built_in">size</span>);</span><br><span class="line">skb_shinfo(skb)-&gt;nr_frags = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __skb_fill_page_desc(struct sk_buff *skb, <span class="keyword">int</span> i,</span><br><span class="line">struct page *page, <span class="keyword">int</span> off, <span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">skb_frag_t</span> *frag = &amp;skb_shinfo(skb)-&gt;frags[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Propagate page pfmemalloc to the skb if we can. The problem is</span></span><br><span class="line"><span class="comment"> * that not all callers have unique ownership of the page but rely</span></span><br><span class="line"><span class="comment"> * on page_is_pfmemalloc doing the right thing(tm).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">frag-&gt;bv_page  = page;</span><br><span class="line">frag-&gt;bv_offset  = off;</span><br><span class="line">skb_frag_size_set(frag, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">page = compound_head(page);</span><br><span class="line"><span class="keyword">if</span> (page_is_pfmemalloc(page))</span><br><span class="line">skb-&gt;pfmemalloc= <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用skb_header_pointer() 来获取指定位置指定大小的数据，该方法有两种返回值，如果offset + len 位于skb-&gt;data 中，则返回skb-&gt;data 对应偏移量的指针。否则将这部分数据拷贝到本地buffer 中，并返回这个buffer 的指针，当然如果offset+len 是不合理值该方法会返回null.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> * __must_check</span><br><span class="line">__skb_header_pointer(<span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">int</span> offset,</span><br><span class="line">     <span class="keyword">int</span> len, <span class="keyword">void</span> *data, <span class="keyword">int</span> hlen, <span class="keyword">void</span> *<span class="built_in">buffer</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hlen - offset &gt;= len)</span><br><span class="line"><span class="keyword">return</span> data + offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skb ||</span><br><span class="line">    skb_copy_bits(skb, offset, <span class="built_in">buffer</span>, len) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> * __must_check</span><br><span class="line">skb_header_pointer(<span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">void</span> *<span class="built_in">buffer</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __skb_header_pointer(skb, offset, len, skb-&gt;data,</span><br><span class="line">    skb_headlen(skb), <span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len)</code> 可用于直接把offset 处len 长度的数据从sk_buff 中拷贝到to 中，它会检查线性buffer 的大小和offset 是否重合，从而正确从线性buffer 和page buffer 中读取到连续的数据。</p><p>参考链接</p><ul><li><a href="http://vger.kernel.org/~davem/skb.html" target="_blank" rel="noopener">How SKBs work(skb)</a></li><li><a href="http://vger.kernel.org/~davem/skb_data.html" target="_blank" rel="noopener">How SKBs work(skb_data)</a></li><li><a href="https://elixir.bootlin.com/linux/v5.9/source/include/linux/skbuff.h" target="_blank" rel="noopener">skbuff.h</a></li><li><a href="https://elixir.bootlin.com/linux/v5.9/source/net/core/skbuff.c" target="_blank" rel="noopener">skbuff.c</a></li><li><a href="https://stackoverflow.com/questions/13588639/whats-the-correct-way-to-process-all-the-payload-of-a-sk-buff-packet-in-linux" target="_blank" rel="noopener">What’s the correct way to process all the payload of a sk_buff packet in Linux</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://elixir.bootlin.com/linux/v5.9/source/include/linux/skbuff.h#L713&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sk_buff&lt;/a&gt; 是Linux 网络中的重要数据结构，每个包的发送和接收都要处理这个结构体。&lt;/p&gt;
&lt;p&gt;这个结构体比较长，只讨论部分字段。开头是一个联合，它要么在一个链表里，要么在一个rb tree（netem/tcp)里。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://llcblog.com/tags/Linux/"/>
    
    <category term="sk_buff" scheme="https://llcblog.com/tags/sk-buff/"/>
    
    <category term="kernel" scheme="https://llcblog.com/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>使用ct_state 实现出口放行防火墙</title>
    <link href="https://llcblog.com/2020/05/15/ovs-conntrack/"/>
    <id>https://llcblog.com/2020/05/15/ovs-conntrack/</id>
    <published>2020-05-15T12:28:29.000Z</published>
    <updated>2020-05-15T12:31:00.295Z</updated>
    
    <content type="html"><![CDATA[<p>openflow 本身没有定义连接状态，需要控制器做sdn 防火墙。但ovs 的实现中支持了conn track，可以利用Linux 的nf_conntrack（类似iptables）。 </p><a id="more"></a><h2 id="出口方向放行"><a href="#出口方向放行" class="headerlink" title="出口方向放行"></a>出口方向放行</h2><p>第一条flow 是先用ct_state=-trk 匹配出所有的包，action=ct(table=0) 加上trk 再回到table 0继续处理。</p><p>第二条flow 匹配所有带有trk 标记且源地址为a.b.c.d（用于标示本地虚拟机）的”new”包，例如icmp ping，tcp 的主动握手包等，通过ct(commit) 创建nf_conntrack 项，并放行（normal）。</p><p>第三条flow 匹配所有已经被追踪并建立链接的包（无状态协议icmp，udp 等也可以正常被nf_conntrack 追踪），均放行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ovs-ofctl add-flow "cookie=0x100,icmp,ct_state=-trk,actions=ct(table=0)"</span></span><br><span class="line"><span class="comment"># ovs-ofctl add-flow "cookie=0x100,icmp,ct_state=+trk+new,nw_src=a.b.c.d actions=ct(commit),normal"</span></span><br><span class="line"><span class="comment"># ovs-ofctl add-flow "cookie=0x100,icmp,ct_state=+trk+est actions=normal"</span></span><br></pre></td></tr></table></figure><h2 id="入口方向放行"><a href="#入口方向放行" class="headerlink" title="入口方向放行"></a>入口方向放行</h2><p>配置入口方向放行时第一条flow 已经做了对所有包添加trk，和放行+trk+est，因此入口放行只需要允许+trk+new，同样通过ct(commit) 建立nf_conntrack 项并normal 放行即可。nw_src 用于指定希望放行的对方地址，nw_dst 为本地虚拟机地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ovs-ofctl add-flow "cookie=0x100,icmp,ct_state=+trk+new,nw_src=e.f.g.h/x,nw_dst=a.b.c.d actions=ct(commit),normal"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;openflow 本身没有定义连接状态，需要控制器做sdn 防火墙。但ovs 的实现中支持了conn track，可以利用Linux 的nf_conntrack（类似iptables）。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="ovs" scheme="https://llcblog.com/tags/ovs/"/>
    
  </entry>
  
  <entry>
    <title>/dev 下的null, zero, random等文件是怎么来的</title>
    <link href="https://llcblog.com/2020/03/07/dev-null-zero-random/"/>
    <id>https://llcblog.com/2020/03/07/dev-null-zero-random/</id>
    <published>2020-03-07T06:47:44.000Z</published>
    <updated>2020-03-07T06:59:17.259Z</updated>
    
    <content type="html"><![CDATA[<p>这些设备文件定义在 <a href="https://github.com/torvalds/linux/blob/master/drivers/char/mem.c" target="_blank" rel="noopener">linux/drivers/char/mem.c</a> 的<a href="https://github.com/torvalds/linux/blob/master/drivers/char/mem.c#L881" target="_blank" rel="noopener">devlist</a> 中。就像文件名和结构体名描述的，它们是基于内存的字符设备。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">memdev</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">umode_t</span> mode;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line"><span class="keyword">fmode_t</span> fmode;</span><br><span class="line">&#125; devlist[] = &#123;</span><br><span class="line">#ifdef CONFIG_DEVMEM</span><br><span class="line"> [<span class="number">1</span>] = &#123; <span class="string">"mem"</span>, <span class="number">0</span>, &amp;mem_fops, FMODE_UNSIGNED_OFFSET &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_DEVKMEM</span><br><span class="line"> [<span class="number">2</span>] = &#123; <span class="string">"kmem"</span>, <span class="number">0</span>, &amp;kmem_fops, FMODE_UNSIGNED_OFFSET &#125;,</span><br><span class="line">#endif</span><br><span class="line"> [<span class="number">3</span>] = &#123; <span class="string">"null"</span>, <span class="number">0666</span>, &amp;null_fops, <span class="number">0</span> &#125;,</span><br><span class="line">#ifdef CONFIG_DEVPORT</span><br><span class="line"> [<span class="number">4</span>] = &#123; <span class="string">"port"</span>, <span class="number">0</span>, &amp;port_fops, <span class="number">0</span> &#125;,</span><br><span class="line">#endif</span><br><span class="line"> [<span class="number">5</span>] = &#123; <span class="string">"zero"</span>, <span class="number">0666</span>, &amp;zero_fops, <span class="number">0</span> &#125;,</span><br><span class="line"> [<span class="number">7</span>] = &#123; <span class="string">"full"</span>, <span class="number">0666</span>, &amp;full_fops, <span class="number">0</span> &#125;,</span><br><span class="line"> [<span class="number">8</span>] = &#123; <span class="string">"random"</span>, <span class="number">0666</span>, &amp;random_fops, <span class="number">0</span> &#125;,</span><br><span class="line"> [<span class="number">9</span>] = &#123; <span class="string">"urandom"</span>, <span class="number">0666</span>, &amp;urandom_fops, <span class="number">0</span> &#125;,</span><br><span class="line">#ifdef CONFIG_PRINTK</span><br><span class="line">[<span class="number">11</span>] = &#123; <span class="string">"kmsg"</span>, <span class="number">0644</span>, &amp;kmsg_fops, <span class="number">0</span> &#125;,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件系统初始化时，会调用<a href="https://github.com/torvalds/linux/blob/master/drivers/char/mem.c#L942" target="_blank" rel="noopener">chr_dev_init</a> 函数，通过一个for 循环对devlist 中的这些设备进行初始化，并创建设备文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">chr_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (register_chrdev(MEM_MAJOR, <span class="string">"mem"</span>, &amp;memory_fops))</span><br><span class="line">printk(<span class="string">"unable to get major %d for memory devs\n"</span>, MEM_MAJOR);</span><br><span class="line"></span><br><span class="line">mem_class = class_create(THIS_MODULE, <span class="string">"mem"</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(mem_class))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(mem_class);</span><br><span class="line"></span><br><span class="line">mem_class-&gt;devnode = mem_devnode;</span><br><span class="line"><span class="keyword">for</span> (minor = <span class="number">1</span>; minor &lt; ARRAY_SIZE(devlist); minor++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!devlist[minor].name)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create /dev/port?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((minor == DEVPORT_MINOR) &amp;&amp; !arch_has_dev_port())</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">device_create(mem_class, <span class="literal">NULL</span>, MKDEV(MEM_MAJOR, minor),</span><br><span class="line">      <span class="literal">NULL</span>, devlist[minor].name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tty_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/torvalds/linux/blob/master/drivers/base/core.c#L3203" target="_blank" rel="noopener">device_create</a> 函数在<a href="https://github.com/torvalds/linux/blob/master/drivers/base/core.c" target="_blank" rel="noopener">linux/drivers/base/core.c</a> 中，它是一个包裹函数，负责将参数传入并调用device_create_vargs 再调用实际干活的<a href="https://github.com/torvalds/linux/blob/master/drivers/base/core.c#L3105" target="_blank" rel="noopener">device_create_groups_vargs</a>.</p><p>device_create_groups_vargs先通过<a href="https://github.com/torvalds/linux/blob/master/drivers/base/core.c#L1954" target="_blank" rel="noopener">device_initialize</a> 负责初始化一个空的设备的结构体dev，之后根据从device_create 传进来的参数填充数据，最后调用<a href="https://github.com/torvalds/linux/blob/master/drivers/base/core.c#L2358" target="_blank" rel="noopener">device_add</a> 函数，传入刚刚填好数据的dev，在/sys/devices 目录下创建目录结构(例如/sys/devices/virtual/mem/null) ，并在/sys/class 下创建软链接(例如/sys/class/mem/null/)，该目录下有设备的major:minor号，设备名称和权限等。</p><p>device_add 的最后，通过调用<a href="https://github.com/torvalds/linux/blob/master/drivers/base/devtmpfs.c#L109" target="_blank" rel="noopener">devtmpfs_create_node</a> 函数，在devtmpfs，也就是/dev 目录下创建设备对应的文件(例如/dev/null)。</p><p>在/dev 下的设备文件创建完成后，就可以从用户态通过该文件对设备进行操作，不同的设备实现的fops 数量和方法也不同，其中null 和zero 的定义和实现都在 <a href="https://github.com/torvalds/linux/blob/master/drivers/char/mem.c" target="_blank" rel="noopener">linux/drivers/char/mem.c</a> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">null_fops</span> = &#123;</span></span><br><span class="line">.llseek= null_lseek,</span><br><span class="line">.<span class="built_in">read</span>= read_null,</span><br><span class="line">.<span class="built_in">write</span>= write_null,</span><br><span class="line">.read_iter= read_iter_null,</span><br><span class="line">.write_iter= write_iter_null,</span><br><span class="line">.splice_write= splice_write_null,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">zero_fops</span> = &#123;</span></span><br><span class="line">.llseek= zero_lseek,</span><br><span class="line">.<span class="built_in">write</span>= write_zero,</span><br><span class="line">.read_iter= read_iter_zero,</span><br><span class="line">.write_iter= write_iter_zero,</span><br><span class="line">.mmap= mmap_zero,</span><br><span class="line">.get_unmapped_area = get_unmapped_area_zero,</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line">.mmap_capabilities = zero_mmap_capabilities,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中部分方法还是zero 和null 共用的，例如zero_lseek 和null_lseek（设置到文件起始位置），write_null 和write_zero 等就是同一个函数实现（只返回个数字，但不发生实际写入）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zero_lseeknull_lseek</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> loff_t <span class="title">null_lseek</span><span class="params">(struct file *file, <span class="keyword">loff_t</span> offset, <span class="keyword">int</span> orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> file-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_zerowrite_null</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">write_null</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read_null 简单的返回一个0, 而<a href="https://github.com/torvalds/linux/blob/master/drivers/char/mem.c#L705" target="_blank" rel="noopener">read_iter_zero</a> 则是通过memset 的方式向读buffer 写满0.</p><p>random 的实现在<a href="https://github.com/torvalds/linux/blob/master/drivers/char/random.c#L1960" target="_blank" rel="noopener">linux/drivers/char/random.c</a> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">random_fops</span> = &#123;</span></span><br><span class="line">.<span class="built_in">read</span>  = random_read,</span><br><span class="line">.<span class="built_in">write</span> = random_write,</span><br><span class="line">.poll  = random_poll,</span><br><span class="line">.unlocked_ioctl = random_ioctl,</span><br><span class="line">.compat_ioctl = compat_ptr_ioctl,</span><br><span class="line">.fasync = random_fasync,</span><br><span class="line">.llseek = noop_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的方法实现也比较复杂，有兴趣可以去研究一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这些设备文件定义在 &lt;a href=&quot;https://github.com/torvalds/linux/blob/master/drivers/char/mem.c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;linux/drivers/char/mem.c&lt;/a&gt; 的&lt;a href=&quot;https://github.com/torvalds/linux/blob/master/drivers/char/mem.c#L881&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;devlist&lt;/a&gt; 中。就像文件名和结构体名描述的，它们是基于内存的字符设备。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://llcblog.com/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://llcblog.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>NUMA 内存策略 preferred 的效果</title>
    <link href="https://llcblog.com/2020/02/20/numa-memory-policy/"/>
    <id>https://llcblog.com/2020/02/20/numa-memory-policy/</id>
    <published>2020-02-20T08:36:21.000Z</published>
    <updated>2020-02-20T10:28:41.480Z</updated>
    
    <content type="html"><![CDATA[<p>和聂工一起在如何在硬件资源有限的情况下尽量多的运行虚拟机的泥潭中苦苦挣扎。</p><p>想利用numa 的优势，但又因为内存资源总是不够，使用strict 的策略可能会导致oom，只好允许进程跨numa node 使用内存。<br>当在一台启用了numa 的物理机上，通过libvirt 的xml 给虚拟机添加内存策略preferred 后，期待的是它会先使用preferred 的node 上的内存，只有这个node 上的内存不足时，才考虑使用其他node.<br>但实际部署下来，经常发现很多进程在两个node 上都有内存，但通过numastat -m 来看其实preferred 的node 上往往还有不少可释放的buffer/cache 等。</p><a id="more"></a><p>后来查询得知这个行为和zone_reclaim_mode 有关。当zone_reclaim_mode 为0 时，如果当前zone 的内存低于low 水线，会倾向于从其他zone 申请内存，而所有的zone 按照numa 访问代价排成一个list，按顺序依次检查这些zone 的free pages 和low 水线的关系，并尝试分配内存。<br>当zone_reclaim_mode 为1 时，会倾向于先对当前zone 进行内存回收，回收一部分buffer/cache 后如果满足需求则从当前zone 进行分配。</p><p>从代码上来看，通过<strong>alloc_pages_nodemask 分配内存时，会调用get_page_from_freelist 函数，而当该函数分配不出page 时，则进入</strong>alloc_pages_slowpath.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/page_alloc.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the 'heart' of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class"><span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))         <span class="comment">// 这里根据preferred 的node id 构建zone list，存在ac 中。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">    page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">    <span class="keyword">if</span> (likely(page))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">    ...</span><br><span class="line">page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line">out:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 只观察get_page_from_freelist<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// mm/page_alloc.c</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_page_from_freelist goes through the zonelist trying to allocate</span></span><br><span class="line"><span class="comment"> * a page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class"><span class="title">get_page_from_freelist</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    for_next_zone_zonelist_nodemask(zone, z, ac-&gt;zonelist, ac-&gt;high_zoneidx,<span class="comment">// 遍历已经通过访问代价排序的zone list</span></span><br><span class="line">ac-&gt;nodemask) &#123;</span><br><span class="line">            ...</span><br><span class="line">    mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);           <span class="comment">// 这里的alloc_flags 是从__alloc_pages_nodemask 传进来的参数，是ALLOC_WMARK_LOW 和其他flags 或起来的结果。</span></span><br><span class="line">    <span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,                         <span class="comment">// 这里会检查free pages 是否低过low 水线。不低于low 水线可以直接尝试从该zone 分配内存。</span></span><br><span class="line">       ac_classzone_idx(ac), alloc_flags)) &#123;            </span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (node_reclaim_mode == <span class="number">0</span> ||                                   <span class="comment">// 低于low 水线的情况下，检查node_reclaim_mode，如果为0 或zone 不允许reclaim 则跳过该zone.</span></span><br><span class="line">                    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))    </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);          <span class="comment">// 其他情况下开始对该zone 进行reclaim.</span></span><br><span class="line">                <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">                <span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line">                    <span class="comment">/* did not scan */</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line">                    <span class="comment">/* scanned but unreclaimable */</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">/* did we reclaim enough */</span></span><br><span class="line">                    <span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,                    <span class="comment">// reclaim 到足够的内存时，尝试从该zone 分配内存。</span></span><br><span class="line">                            ac_classzone_idx(ac), alloc_flags))</span><br><span class="line">                        <span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">try_this_zone:</span><br><span class="line">    page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,            <span class="comment">// rmqueue 已经是尝试从当前zone 分配内存了。</span></span><br><span class="line">    gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此看来使用preferred 的模式时，由于buffer/cache 的存在free pages 会变少，而free 在low 以下时如果zone_reclaim_mode 为0 就会从其他zone 分配内存，所以看起来是多数进程在每个node 上都有点内存。而当zone_reclaim_mode 为1 时，倾向于先回收本zone 的buffer/cache，这个过程会导致sar 中的pgscand 上涨。</p><p>参考：<a href="https://engineering.linkedin.com/performance/optimizing-linux-memory-management-low-latency-high-throughput-databases#reproduce" target="_blank" rel="noopener">https://engineering.linkedin.com/performance/optimizing-linux-memory-management-low-latency-high-throughput-databases#reproduce</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;和聂工一起在如何在硬件资源有限的情况下尽量多的运行虚拟机的泥潭中苦苦挣扎。&lt;/p&gt;
&lt;p&gt;想利用numa 的优势，但又因为内存资源总是不够，使用strict 的策略可能会导致oom，只好允许进程跨numa node 使用内存。&lt;br&gt;当在一台启用了numa 的物理机上，通过libvirt 的xml 给虚拟机添加内存策略preferred 后，期待的是它会先使用preferred 的node 上的内存，只有这个node 上的内存不足时，才考虑使用其他node.&lt;br&gt;但实际部署下来，经常发现很多进程在两个node 上都有内存，但通过numastat -m 来看其实preferred 的node 上往往还有不少可释放的buffer/cache 等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://llcblog.com/tags/Linux/"/>
    
    <category term="numa" scheme="https://llcblog.com/tags/numa/"/>
    
  </entry>
  
  <entry>
    <title>在linux kernel 源码中搜索syscall 的实现</title>
    <link href="https://llcblog.com/2020/02/20/how-to-find-syscall/"/>
    <id>https://llcblog.com/2020/02/20/how-to-find-syscall/</id>
    <published>2020-02-20T08:28:59.000Z</published>
    <updated>2020-02-20T08:33:26.810Z</updated>
    
    <content type="html"><![CDATA[<p>个人习惯用grep 搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">'SYSCALL_DEFINE.*&lt;syscallname&gt;'</span> **/*.[ch]</span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line">$ grep <span class="string">'SYSCALL_DEFINE.*mmap'</span> **/*.[ch]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人习惯用grep 搜索：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://llcblog.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>一次ping 遇到Invalid argument 报错的问题</title>
    <link href="https://llcblog.com/2020/02/11/ping-invalid-argument/"/>
    <id>https://llcblog.com/2020/02/11/ping-invalid-argument/</id>
    <published>2020-02-11T11:16:08.000Z</published>
    <updated>2020-02-20T08:34:56.930Z</updated>
    
    <content type="html"><![CDATA[<p>一台线上的虚拟机，ping localhost 时出现了<code>sendmsg: Invalid argument</code>的错误，偶尔会正常，同时ping 同网段的机器都有问题，但ping 跨网段的机器没有问题。但使用的ping 命令并没有附加什么参数。<br>查看strace 的结果，发现是在sendto 的系统调用中返回的EINVAL 错误，检查<code>man 2 sendto</code>，也只是说<code>Invalid argument passed</code>，但对比正常机器，strace 中输出的函数调用传参并无问题。</p><a id="more"></a><p>尝试了加路由，ifdown/ifup 等操作后，都没什么进展，之后做了些搜索，有人遇到过相同的问题，但没有回答。<br>考虑到ping 同网段也有相同问题，可能不是lo 网卡故障，是否跨网段涉及到arp 问题，马上用ip neigh 命令进行检查，发现只有网关的一条arp cache. 马上尝试手动添加arp cache，却出现了buffer 不足无法添加的报错，问题呼之欲出。<br>考虑到这台机器用作运行docker，通过ip netns list 查看到有多个network 的namespace（有名字的），通过ip netns exec &lt;name&gt; ip neigh 发现q已经有较多的arp cache，而这个docker 正好是用桥的方式使用网络，且是一个/22 的网段，多个netns 中大量的arp cache 占满了buffer，导致ping 同网段时没办法缓存新的ip-mac 映射。之后修改了net.ipv4.neigh.default.gc_thresh3 问题得到解决。</p><p>不过通过ip neigh 来看ping lo 没有产生127.0.0.1 的arp cache，似乎不需要，但是ping 也失败了，不知道为啥=。=</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一台线上的虚拟机，ping localhost 时出现了&lt;code&gt;sendmsg: Invalid argument&lt;/code&gt;的错误，偶尔会正常，同时ping 同网段的机器都有问题，但ping 跨网段的机器没有问题。但使用的ping 命令并没有附加什么参数。&lt;br&gt;查看strace 的结果，发现是在sendto 的系统调用中返回的EINVAL 错误，检查&lt;code&gt;man 2 sendto&lt;/code&gt;，也只是说&lt;code&gt;Invalid argument passed&lt;/code&gt;，但对比正常机器，strace 中输出的函数调用传参并无问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://llcblog.com/tags/Linux/"/>
    
    <category term="ping" scheme="https://llcblog.com/tags/ping/"/>
    
    <category term="arp" scheme="https://llcblog.com/tags/arp/"/>
    
  </entry>
  
  <entry>
    <title>Linux 网络bond mode 4 的xmit_hash_policy layer3+4 到底是如何hash 的</title>
    <link href="https://llcblog.com/2020/01/10/how-bonding-lacp-xmit-hash-work/"/>
    <id>https://llcblog.com/2020/01/10/how-bonding-lacp-xmit-hash-work/</id>
    <published>2020-01-10T13:08:08.000Z</published>
    <updated>2020-01-10T13:48:52.312Z</updated>
    
    <content type="html"><![CDATA[<p>在通过iperf3 测试4 块网卡做的lacp 链路聚合时，xmit_hash_policy 选择的是layer3+4. 当iperf3 指定的线程数比较少时，总是打不满带宽。<br>例如在源目的IP和目的端口不变的情况下，四个线程使用连续的4个源端口10001~10004 (iperf3 参数 -P 4-B src_ip –cport 10001)测试tcp 只能打出3 个网卡的效果，从/proc/net/dev 中查看计数，以及从tcpdump 的抓包中，发现只有1,2,3 三块网卡有出流量。<br>其中10001 用网卡1,10002 和10003 用网卡2,10004 用网卡3，网卡四没有发包。<br>后续测试其他连续端口，也发现类似的情况，甚至有时候只能打出两张卡的效果。</p><p>于是去查询了<a href="https://www.kernel.org/doc/Documentation/networking/bonding.txt" target="_blank" rel="noopener">kernel bonding 文档</a> 得知其hash 方式如下：</p><a id="more"></a><blockquote><pre><code>layer3+4   This policy uses upper layer protocol information,   when available, to generate the hash.  This allows for   traffic to a particular network peer to span multiple   slaves, although a single connection will not span   multiple slaves.   The formula for unfragmented TCP and UDP packets is   hash = source port, destination port (as in the header)   hash = hash XOR source IP XOR destination IP   hash = hash XOR (hash RSHIFT 16)   hash = hash XOR (hash RSHIFT 8)   And then hash is reduced modulo slave count.   If the protocol is IPv6 then the source and destination   addresses are first hashed using ipv6_addr_hash.   For fragmented TCP or UDP packets and all other IPv4 and   IPv6 protocol traffic, the source and destination port   information is omitted.  For non-IP traffic, the   formula is the same as for the layer2 transmit hash   policy.   This algorithm is not fully 802.3ad compliant.  A   single TCP or UDP conversation containing both   fragmented and unfragmented packets will see packets   striped across two interfaces.  This may result in out   of order delivery.  Most traffic types will not meet   this criteria, as TCP rarely fragments traffic, and   most UDP traffic is not involved in extended   conversations.  Other implementations of 802.3ad may   or may not tolerate this noncompliance.</code></pre></blockquote><p>但按照这个算法算下来的话，10001-10004 四个端口是可以分到四块网卡的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xmit_hash</span><span class="params">(slaves, sport, dport, sip, dip)</span>:</span></span><br><span class="line">    hash = (sport &lt;&lt; <span class="number">16</span>) + dport</span><br><span class="line">    hash = hash ^ sip ^ dip</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> (hash % slaves)</span><br></pre></td></tr></table></figure><p>搞不定，就去翻了下源码<a href="https://github.com/torvalds/linux/blob/master/drivers/net/bonding/bond_main.c#L3376" target="_blank" rel="noopener">drivers/net/bonding/bond_main.c</a>，结果发现这玩意居然和文档里写的不一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash ^= (__force u32)flow_get_u32_dst(&amp;flow) ^</span><br><span class="line">(__force u32)flow_get_u32_src(&amp;flow);</span><br><span class="line">hash ^= (hash &gt;&gt; <span class="number">16</span>);</span><br><span class="line">hash ^= (hash &gt;&gt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>翻译成python 大概是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xmit_hash</span><span class="params">(slaves, sport, dport, sip, dip)</span>:</span></span><br><span class="line">    hash = (sport &lt;&lt; <span class="number">16</span>) + dport</span><br><span class="line">    hash = hash ^ sip ^ dip</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> ((hash&gt;&gt;<span class="number">1</span>) % slaves)</span><br></pre></td></tr></table></figure><p>这个hash &gt;&gt; 1 就很讲究了，这样算出来在4 网卡聚合的情况下，保持源目的地址和目的端口不变，还是上面的例子，(2n, 2n+1)的源端口号会被分配到同一块卡上，就是10001 一块卡， 10002 和10003 一块卡，10004 一块卡。用三块卡，闲置一块卡，这样的结果确实和测试吻合。</p><p>那么为什么要这么搞呢？好在git log 里有答案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git log -p b5f862180d7011d9575d0499fa37f0f25b423b12</span></span><br><span class="line">Author: Hangbin Liu &lt;liuhangbin@gmail.com&gt;</span><br><span class="line">Date:   Mon Nov 6 09:01:57 2017 +0800</span><br><span class="line"></span><br><span class="line">    bonding: discard lowest <span class="built_in">hash</span> bit <span class="keyword">for</span> 802.3ad layer3+4</span><br><span class="line">    </span><br><span class="line">    After commit 07f4c90062f8 (<span class="string">"tcp/dccp: try to not exhaust ip_local_port_range</span></span><br><span class="line"><span class="string">    in connect()"</span>), we will try to use even ports <span class="keyword">for</span> connect(). Then <span class="keyword">if</span> an</span><br><span class="line">    application (seen clearly with iperf) opens multiple streams to the same</span><br><span class="line">    destination IP and port, each stream will be given an even <span class="built_in">source</span> port.</span><br><span class="line">    </span><br><span class="line">    So the bonding driver<span class="string">'s simple xmit_hash_policy based on layer3+4 addressing</span></span><br><span class="line"><span class="string">    will always hash all these streams to the same interface. And the total</span></span><br><span class="line"><span class="string">    throughput will limited to a single slave.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Change the tcp code will impact the whole tcp behavior, only for bonding</span></span><br><span class="line"><span class="string">    usage. Paolo Abeni suggested fix this by changing the bonding code only,</span></span><br><span class="line"><span class="string">    which should be more reasonable, and less impact.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Fix this by discarding the lowest hash bit because it contains little entropy.</span></span><br><span class="line"><span class="string">    After the fix we can re-balance between slaves.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Signed-off-by: Paolo Abeni &lt;pabeni@redhat.com&gt;</span></span><br><span class="line"><span class="string">    Signed-off-by: Hangbin Liu &lt;liuhangbin@gmail.com&gt;</span></span><br><span class="line"><span class="string">    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span></span><br><span class="line"><span class="string">index c99dc59d729b..76e8054bfc4e 100644</span></span><br><span class="line"><span class="string">--- a/drivers/net/bonding/bond_main.c</span></span><br><span class="line"><span class="string">+++ b/drivers/net/bonding/bond_main.c</span></span><br><span class="line"><span class="string">@@ -3253,7 +3253,7 @@ u32 bond_xmit_hash(struct bonding *bond, struct sk_buff *skb)</span></span><br><span class="line"><span class="string">        hash ^= (hash &gt;&gt; 16);</span></span><br><span class="line"><span class="string">        hash ^= (hash &gt;&gt; 8);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">-       return hash;</span></span><br><span class="line"><span class="string">+       return hash &gt;&gt; 1;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure><p>看名字这位仁兄好像还是个中国人，大意是在2015 的另一个提交07f4c90062f8 改变了一些随机端口号的使用规则，现在使用iperf3 等工具时，随机的源端口号是每次+2，而不是每次+1，这样如果还是原来的xmit_hash_policy 会有一些问题，例如4 网卡的话永远都只能hash 到两个卡。所以他舍弃了hash 的最后一位来应对这个变化。<br>这个commit 是在2017 年提交，在CentOS/RHEL 7.3 的3.10.0-514 内核中还没有被添加进去。</p><p>对于随机端口号每次+2 这个现象，之前用python 做测试的时候也遇见过不过没有深究，现在也找到了答案，算是缘分吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在通过iperf3 测试4 块网卡做的lacp 链路聚合时，xmit_hash_policy 选择的是layer3+4. 当iperf3 指定的线程数比较少时，总是打不满带宽。&lt;br&gt;例如在源目的IP和目的端口不变的情况下，四个线程使用连续的4个源端口10001~10004 (iperf3 参数 -P 4-B src_ip –cport 10001)测试tcp 只能打出3 个网卡的效果，从/proc/net/dev 中查看计数，以及从tcpdump 的抓包中，发现只有1,2,3 三块网卡有出流量。&lt;br&gt;其中10001 用网卡1,10002 和10003 用网卡2,10004 用网卡3，网卡四没有发包。&lt;br&gt;后续测试其他连续端口，也发现类似的情况，甚至有时候只能打出两张卡的效果。&lt;/p&gt;
&lt;p&gt;于是去查询了&lt;a href=&quot;https://www.kernel.org/doc/Documentation/networking/bonding.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kernel bonding 文档&lt;/a&gt; 得知其hash 方式如下：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://llcblog.com/tags/Linux/"/>
    
    <category term="bonding" scheme="https://llcblog.com/tags/bonding/"/>
    
  </entry>
  
  <entry>
    <title>golang xml 如何忽略空结构体</title>
    <link href="https://llcblog.com/2020/01/09/Golang-xml-omitempty/"/>
    <id>https://llcblog.com/2020/01/09/Golang-xml-omitempty/</id>
    <published>2020-01-09T13:45:24.000Z</published>
    <updated>2020-01-09T15:29:54.112Z</updated>
    
    <content type="html"><![CDATA[<p>golang 解析XMl <a href="https://golang.org/pkg/encoding/xml/#Marshal" target="_blank" rel="noopener">encoding/xml.Marshal</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/xml"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">City, State <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName   xml.Name <span class="string">`xml:"person"`</span></span><br><span class="line">Id        <span class="keyword">int</span>      <span class="string">`xml:"id,attr"`</span></span><br><span class="line">FirstName <span class="keyword">string</span>   <span class="string">`xml:"name&gt;first"`</span></span><br><span class="line">LastName  <span class="keyword">string</span>   <span class="string">`xml:"name&gt;last"`</span></span><br><span class="line">Age       <span class="keyword">int</span>      <span class="string">`xml:"age"`</span></span><br><span class="line">Height    <span class="keyword">float32</span>  <span class="string">`xml:"height,omitempty"`</span></span><br><span class="line">Married   <span class="keyword">bool</span></span><br><span class="line">Address</span><br><span class="line">Comment <span class="keyword">string</span> <span class="string">`xml:",comment"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v := &amp;Person&#123;Id: <span class="number">13</span>, FirstName: <span class="string">"John"</span>, LastName: <span class="string">"Doe"</span>, Age: <span class="number">42</span>&#125;</span><br><span class="line">v.Comment = <span class="string">" Need more details. "</span></span><br><span class="line">v.Address = Address&#123;<span class="string">"Hanga Roa"</span>, <span class="string">"Easter Island"</span>&#125;</span><br><span class="line"></span><br><span class="line">output, err := xml.MarshalIndent(v, <span class="string">"  "</span>, <span class="string">"    "</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">os.Stdout.Write(output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中<code>Height    float32  `xml:&quot;height,omitempty&quot;`</code>  这里的omitempty 用于表示如果Height 为空则不输出在XML 中，文档中解释为:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- a field with a tag including the &quot;omitempty&quot; option is omitted</span><br><span class="line">  if the field value is empty. The empty values are false, 0, any</span><br><span class="line">  nil pointer or interface value, and any array, slice, map, or</span><br><span class="line">  string of length zero.</span><br></pre></td></tr></table></figure></blockquote><p>使用时发现对于struct，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">Where <span class="keyword">string</span> <span class="string">`xml:"where,attr"`</span></span><br><span class="line">Addr  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"Person"`</span></span><br><span class="line">Name    <span class="keyword">string</span>   <span class="string">`xml:",omitempty"`</span></span><br><span class="line">TestEmail<span class="string">`xml:",omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Email 没有赋予初值，运行时成员Test仍然会被放到XML里，而不是丢弃：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/xml"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">Where <span class="keyword">string</span> <span class="string">`xml:"where,attr"`</span></span><br><span class="line">Addr  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"Person"`</span></span><br><span class="line">Name    <span class="keyword">string</span>   <span class="string">`xml:",omitempty"`</span></span><br><span class="line">Test    Email    <span class="string">`xml:",omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line">v := Result&#123;Name: <span class="string">"myname"</span>&#125;</span><br><span class="line">resultxml, _ := xml.MarshalIndent(v, <span class="string">"  "</span>, <span class="string">"    "</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(resultxml))</span><br><span class="line">fmt.Printf(<span class="string">"XMLName: %#v\n"</span>, v.XMLName)</span><br><span class="line">fmt.Printf(<span class="string">"Name: %q\n"</span>, v.Name)</span><br><span class="line">fmt.Printf(<span class="string">"Test: %q\n"</span>, v.Test)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://play.golang.org/p/WGtM2N8Bwah" target="_blank" rel="noopener">输出结果</a>:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &lt;Person&gt;</span><br><span class="line">      &lt;Name&gt;myname&lt;&#x2F;Name&gt;</span><br><span class="line">      &lt;Test where&#x3D;&quot;&quot;&gt;</span><br><span class="line">          &lt;Addr&gt;&lt;&#x2F;Addr&gt;</span><br><span class="line">      &lt;&#x2F;Test&gt;</span><br><span class="line">  &lt;&#x2F;Person&gt;</span><br><span class="line">XMLName: xml.Name&#123;Space:&quot;&quot;, Local:&quot;&quot;&#125;</span><br><span class="line">Name: &quot;myname&quot;</span><br><span class="line">Test: &#123;&quot;&quot; &quot;&quot;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>经查询，文档里确实没有明确指明如果元素是个结构体，即便是空的也不会被忽略，但文档里有说如果是个指针，空的就可以忽略了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"Person"`</span></span><br><span class="line">Name    <span class="keyword">string</span>   <span class="string">`xml:",omitempty"`</span></span><br><span class="line">Test    *Email    <span class="string">`xml:",omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;Person&gt;</span><br><span class="line">     &lt;Name&gt;myname&lt;&#x2F;Name&gt;</span><br><span class="line"> &lt;&#x2F;Person&gt;</span><br><span class="line">XMLName: xml.Name&#123;Space:&quot;&quot;, Local:&quot;&quot;&#125;</span><br><span class="line">Name: &quot;myname&quot;</span><br><span class="line">Test: %!q(*main.Email&#x3D;&lt;nil&gt;)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;golang 解析XMl &lt;a href=&quot;https://golang.org/pkg/encoding/xml/#Marshal&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;encoding/xml.Marshal&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;encoding/xml&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;os&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Address &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		City, State &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Person &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		XMLName   xml.Name &lt;span class=&quot;string&quot;&gt;`xml:&quot;person&quot;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Id        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;      &lt;span class=&quot;string&quot;&gt;`xml:&quot;id,attr&quot;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		FirstName &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;`xml:&quot;name&amp;gt;first&quot;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		LastName  &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;`xml:&quot;name&amp;gt;last&quot;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Age       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;      &lt;span class=&quot;string&quot;&gt;`xml:&quot;age&quot;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Height    &lt;span class=&quot;keyword&quot;&gt;float32&lt;/span&gt;  &lt;span class=&quot;string&quot;&gt;`xml:&quot;height,omitempty&quot;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Married   &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Address&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Comment &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`xml:&quot;,comment&quot;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	v := &amp;amp;Person&amp;#123;Id: &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;, FirstName: &lt;span class=&quot;string&quot;&gt;&quot;John&quot;&lt;/span&gt;, LastName: &lt;span class=&quot;string&quot;&gt;&quot;Doe&quot;&lt;/span&gt;, Age: &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	v.Comment = &lt;span class=&quot;string&quot;&gt;&quot; Need more details. &quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	v.Address = Address&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;Hanga Roa&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Easter Island&quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	output, err := xml.MarshalIndent(v, &lt;span class=&quot;string&quot;&gt;&quot;  &quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;    &quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;error: %v\n&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	os.Stdout.Write(output)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="golang" scheme="https://llcblog.com/tags/golang/"/>
    
    <category term="xml" scheme="https://llcblog.com/tags/xml/"/>
    
    <category term="omitempty" scheme="https://llcblog.com/tags/omitempty/"/>
    
  </entry>
  
  <entry>
    <title>libvirt-go 的一个坑</title>
    <link href="https://llcblog.com/2020/01/07/libvirt-go-GetFreepages/"/>
    <id>https://llcblog.com/2020/01/07/libvirt-go-GetFreepages/</id>
    <published>2020-01-07T14:54:25.000Z</published>
    <updated>2020-03-05T13:48:47.982Z</updated>
    
    <content type="html"><![CDATA[<p>更新：<br>BUG 已经被修复。</p><p>今天和聂工在研究怎么用<a href="https://github.com/libvirt/libvirt-go" target="_blank" rel="noopener">libvirt-go</a> 时，发现GetFreepages 有bug，demo 一跑就报错<br><code>virError(Code=9, Domain=0, Message=&#39;operation failed: page size 679968 is not available on node 0&#39;)</code>.<br>其中这个<code>page size 679968</code>每次跑还会变化。</p><a id="more"></a><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">        libvirt <span class="string">"github.com/libvirt/libvirt-go"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        conn, err := libvirt.NewConnect(<span class="string">"qemu:///system"</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">        doms, err := conn.ListAllDomains(libvirt.CONNECT_LIST_DOMAINS_ACTIVE)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(conn.GetFreePages([]<span class="keyword">uint64</span>&#123;<span class="number">4</span>, <span class="number">2048</span>, <span class="number">1048576</span>&#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="keyword">uint32</span>(<span class="number">0</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用qemu+tcp 的方式去测试，抓包发现发送给libvirtd 的指令里这个参数就已经是错的，也就是问题出现在客户端这边。同时聂工也测试过python，python 的libvirt 库没这个毛病。<br>之后开始debug，因为CentOS 8 没有libvirt-devel 的debuginfo，去CentOS 7 重新装了下环境，还是能复现问题，用gdb 看到这部分进到cgo 里了，源码一顿乱翻，在<a href="https://github.com/libvirt/libvirt-go/blob/master/connect.go#L1900" target="_blank" rel="noopener">GetFreePages</a> 的代码里可以看到这就是个对C 的封装，里面用了go 的unsafe 想把go 的slice 转换成c 的数组。<br>但代码里有一个bug，这玩意是用virNodeGetFreePagesWrapper 调用C 库的，在传递之前，先弄了cpageSizes 和ccounts 俩slice，然后用unsafe 直接把slice 的地址转成int 型指针了了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connect)</span> <span class="title">GetFreePages</span><span class="params">(pageSizes []<span class="keyword">uint64</span>, startCell <span class="keyword">int</span>, maxCells <span class="keyword">uint</span>, flags <span class="keyword">uint32</span>)</span> <span class="params">([]<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> C.LIBVIR_VERSION_NUMBER &lt; <span class="number">1002006</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">uint64</span>&#123;&#125;, makeNotImplementedError(<span class="string">"virNodeGetFreePages"</span>)</span><br><span class="line">&#125;</span><br><span class="line">cpageSizes := <span class="built_in">make</span>([]C.<span class="keyword">uint</span>, <span class="built_in">len</span>(pageSizes))                    <span class="comment">//这俩slice</span></span><br><span class="line">ccounts := <span class="built_in">make</span>([]C.ulonglong, <span class="built_in">len</span>(pageSizes)*<span class="keyword">int</span>(maxCells))    <span class="comment">//这俩slice</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(pageSizes); i++ &#123;</span><br><span class="line">cpageSizes[i] = C.<span class="keyword">uint</span>(pageSizes[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err C.virError</span><br><span class="line">ret := C.virNodeGetFreePagesWrapper(c.ptr, C.<span class="keyword">uint</span>(<span class="built_in">len</span>(pageSizes)), (*C.<span class="keyword">uint</span>)(unsafe.Pointer(&amp;cpageSizes)), C.<span class="keyword">int</span>(startCell),</span><br><span class="line">C.<span class="keyword">uint</span>(maxCells), (*C.ulonglong)(unsafe.Pointer(&amp;ccounts)), C.<span class="keyword">uint</span>(flags), &amp;err) <span class="comment">// 就这做的unsafe</span></span><br><span class="line"><span class="keyword">if</span> ret == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">uint64</span>&#123;&#125;, makeError(&amp;err)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这玩意的函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">virNodeGetFreePagesWrapper(virConnectPtr conn,</span><br><span class="line">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> npages,</span><br><span class="line">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> *pages,</span><br><span class="line">                           <span class="keyword">int</span> startCell,</span><br><span class="line">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> cellCount,</span><br><span class="line">                           <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *counts,</span><br><span class="line">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line">                           virErrorPtr err);</span><br></pre></td></tr></table></figure><p>这里有一个问题，go 的slice 实现大概是这样的(取自CSDN<a href="https://blog.csdn.net/qcrao/article/details/90762019" target="_blank" rel="noopener">深度解密Go语言之unsafe</a>)：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个slice 里有三个成员，其中第一个成员array 是个指针，它指向的是一个数组，也就是说直接把slice 转成uint * 是有问题的，这样转换完得到的其实是slice 指针，而我们需要的<code>unsigned int *pages</code>其实是最终数组的首地址，也就是array 的值，所以需要把它的第一个成员也就是array 的值拿出来才对，不然的话我们拿到的是slice 的地址。<br>之后用gdb 跟了一下，果然<code>page size 679968</code> 中的数字是array 的低32 位，因为传参错误把uint * 理解成uint用了，实际上需要把它和紧挨着的高32 位拼在一起再解引用才是libvirtd 需要的值。<br>从CSDN <a href="https://blog.csdn.net/skh2015java/article/details/79771799" target="_blank" rel="noopener">Golang切片和数组底层详解</a>上，我们找到一个获取数组首地址的方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">200</span>)</span><br><span class="line">ptr := unsafe.Pointer(&amp;s[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>所以修改libvirt-go 的代码connect.go 问题解决:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret := C.virNodeGetFreePagesWrapper(c.ptr, C.<span class="keyword">uint</span>(<span class="built_in">len</span>(pageSizes)), (*C.<span class="keyword">uint</span>)(unsafe.Pointer(&amp;cpageSizes[<span class="number">0</span>])), C.<span class="keyword">int</span>(startCell),</span><br><span class="line">        C.<span class="keyword">uint</span>(maxCells), (*C.ulonglong)(unsafe.Pointer(&amp;ccounts[<span class="number">0</span>])), C.<span class="keyword">uint</span>(flags), &amp;err)</span><br></pre></td></tr></table></figure><p>因为刚开始学golang，感觉这个改法可能不是很科学，感觉哪里有点毛病，回头还得再测测。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新：&lt;br&gt;BUG 已经被修复。&lt;/p&gt;
&lt;p&gt;今天和聂工在研究怎么用&lt;a href=&quot;https://github.com/libvirt/libvirt-go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libvirt-go&lt;/a&gt; 时，发现GetFreepages 有bug，demo 一跑就报错&lt;br&gt;&lt;code&gt;virError(Code=9, Domain=0, Message=&amp;#39;operation failed: page size 679968 is not available on node 0&amp;#39;)&lt;/code&gt;.&lt;br&gt;其中这个&lt;code&gt;page size 679968&lt;/code&gt;每次跑还会变化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="golang" scheme="https://llcblog.com/tags/golang/"/>
    
    <category term="libvirt" scheme="https://llcblog.com/tags/libvirt/"/>
    
    <category term="libvirt-go" scheme="https://llcblog.com/tags/libvirt-go/"/>
    
  </entry>
  
  <entry>
    <title>在AWS 的Amazon Linux 上下载源码</title>
    <link href="https://llcblog.com/2019/12/23/awssourcecode/"/>
    <id>https://llcblog.com/2019/12/23/awssourcecode/</id>
    <published>2019-12-23T10:59:57.000Z</published>
    <updated>2020-01-07T15:52:02.118Z</updated>
    
    <content type="html"><![CDATA[<p>Amazon Linux 和Amazon Linux 2 的repo 里，虽然有例如amzn2-core-source/2 这样的repo，但是里面根本没有软件包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~ % uname -r     </span><br><span class="line">4.14.133-113.105.amzn2.x86_64</span><br><span class="line">~ % yum repolist</span><br><span class="line">Loaded plugins: auto-update-debuginfo, dkms-build-requires, extras_suggestions, langpacks,</span><br><span class="line">              : update-motd</span><br><span class="line">repo id                                repo name                                        status</span><br><span class="line">amzn2-core&#x2F;2&#x2F;x86_64                    Amazon Linux 2 core repository                   17,984</span><br><span class="line">amzn2-core-debuginfo&#x2F;2&#x2F;x86_64          Amazon Linux 2 core repository - debuginfo packa  3,513</span><br><span class="line">amzn2-core-source&#x2F;2                    Amazon Linux 2 core repository - source packages      0</span><br><span class="line">amzn2extra-BCC&#x2F;2&#x2F;x86_64                Amazon Extras repo for BCC                            9</span><br><span class="line">amzn2extra-BCC-debuginfo&#x2F;2&#x2F;x86_64      Amazon Extras debuginfo repo for BCC                  2</span><br><span class="line">amzn2extra-redis4.0&#x2F;2&#x2F;x86_64           Amazon Extras repo for redis4.0                      14</span><br><span class="line">amzn2extra-redis4.0-debuginfo&#x2F;2&#x2F;x86_64 Amazon Extras debuginfo repo for redis4.0             3</span><br><span class="line">amzn2extra-vim&#x2F;2&#x2F;x86_64                Amazon Extras repo for vim                           10</span><br><span class="line">amzn2extra-vim-debuginfo&#x2F;2&#x2F;x86_64      Amazon Extras debuginfo repo for vim                  2</span><br><span class="line">danstiner_softu2f&#x2F;x86_64               danstiner_softu2f                                     0</span><br><span class="line">danstiner_softu2f-source               danstiner_softu2f-source                              0</span><br><span class="line">repolist: 21,537</span><br></pre></td></tr></table></figure><p>其实源代码还是在的，只是要用yumdownloader 来下载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ % yumdownloader --source kernel</span><br></pre></td></tr></table></figure><p>这个在<a href="https://aws.amazon.com/amazon-linux-ami/faqs/#source" target="_blank" rel="noopener">AWS 的FAQ</a>里已经说了，但很多人（包括我）一开始找不到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Amazon Linux 和Amazon Linux 2 的repo 里，虽然有例如amzn2-core-source/2 这样的repo，但是里面根本没有软件包：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://llcblog.com/tags/Linux/"/>
    
    <category term="AWS" scheme="https://llcblog.com/tags/AWS/"/>
    
    <category term="Kernel" scheme="https://llcblog.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>中文测试</title>
    <link href="https://llcblog.com/2019/12/23/test/"/>
    <id>https://llcblog.com/2019/12/23/test/</id>
    <published>2019-12-23T08:32:27.000Z</published>
    <updated>2019-12-23T09:48:57.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="This-is-a-test-post"><a href="#This-is-a-test-post" class="headerlink" title="This is a test post."></a>This is a test post.</h3><p>中文测试内容。</p><p>刚刚安装manjaro linux，vscode 不能切换输入法。<br>参考<a href="https://forum.manjaro.org/t/kde/104454/2" target="_blank" rel="noopener">Manjaro 论坛</a>，创建了.pam_environment 没有效果。<br>随后重新安装了fcitx 和fcitx-im，重启系统就能用了。具体哪个生效的也不知道，不折腾了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;This-is-a-test-post&quot;&gt;&lt;a href=&quot;#This-is-a-test-post&quot; class=&quot;headerlink&quot; title=&quot;This is a test post.&quot;&gt;&lt;/a&gt;This is a test post.&lt;/h3&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="test" scheme="https://llcblog.com/tags/test/"/>
    
    <category term="输入法" scheme="https://llcblog.com/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello world</title>
    <link href="https://llcblog.com/2019/12/19/Hello-world/"/>
    <id>https://llcblog.com/2019/12/19/Hello-world/</id>
    <published>2019-12-18T21:48:50.000Z</published>
    <updated>2019-12-19T06:45:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world!"></a>Hello world!</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hello-world&quot;&gt;&lt;a href=&quot;#Hello-world&quot; class=&quot;headerlink&quot; title=&quot;Hello world!&quot;&gt;&lt;/a&gt;Hello world!&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="test" scheme="https://llcblog.com/tags/test/"/>
    
    <category term="art" scheme="https://llcblog.com/tags/art/"/>
    
  </entry>
  
</feed>
